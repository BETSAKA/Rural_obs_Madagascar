[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Madagascar rural observatory network data validation, preparation, and georeferencing",
    "section": "",
    "text": "Introduction\nThis technical appendix accompanies a scientific paper dedicated to the data from the Rural Observatory Network (ROR) collected between 1995 and 2014. It includes the source code for all figures and visualizations in the paper. It also offers a tutorial on how to georeference this data, which can serve as guidance for various types of analysis. We use computational notebooks in Quarto format with the R programming language, combining code, results, explanations, and multimedia in an interactive way. The source code can be accessed by expanding code blocks like the following one, which produced the figure below.\n\n\nCode\n# Load required libraries\nlibrary(tidyverse)    # A series of packages for data manipulation\nlibrary(haven)        # Required for reading STATA files (.dta)\nlibrary(labelled)     # To work with labelled data from STATA\nlibrary(sf)           # for spatial data handling\nlibrary(tmap)         # for mapping\nlibrary(readxl)       # Read data frames to Excel format\nlibrary(cowplot)      # to combine plots\n\n# Define a function to load and count surveys per observatory for a given year\nload_and_count &lt;- function(year, factorize = FALSE) {\n  # Define file path\n  file_path &lt;- paste0(\"data/ROR_data/\", year, \"/res_deb.dta\")\n  \n  # Load data\n  data &lt;- read_dta(file_path)\n  \n  # Extract label and convert to factors if option\n  if (factorize) {\n    data &lt;- data %&gt;%\n      mutate(across(everything(), as.character),\n             across(where(is.labelled), ~ as.character(as_factor(.))))\n  }\n  \n  # Count surveys per observatory\n  count_data &lt;- data %&gt;%\n    group_by(j0) %&gt;%\n    summarise(survey_count = n()) %&gt;%\n    ungroup() %&gt;%\n    mutate(year = year)  # Add year column\n  \n  return(count_data)\n}\n\n# Generate a list of years\nyears &lt;- 1995:2014\n\n# Use purrr::map_df to loop through each year and bind results\nobs_count &lt;- map_df(years, load_and_count) %&gt;%\n  # Remove rows with observatory \"7 \" and \"NA\", whch are errors\n  filter(j0 != 7 & !is.na(j0)) %&gt;%\n  rename(observatory = j0)\n\n# Read observatory names\nobservatory_names &lt;- readxl::read_xlsx(\"references/observatory_names.xlsx\") %&gt;%\n  select(code, observatory_name = name)\n\n# PAss it to wide.\nobs_count &lt;- obs_count %&gt;%\n  left_join(observatory_names, by = c(\"observatory\" = \"code\")) %&gt;%\n  group_by(observatory_name, year) %&gt;%\n  summarise(survey_count = sum(survey_count))\n\nobs_count_wide &lt;- obs_count %&gt;%\n  pivot_wider(names_from = year, values_from = survey_count)\n\n# Add observatory approximate location\nlocations &lt;- tibble(\n  code = c(1, 2, 3, 4, 12, 13, 15, 16, 21, 22, 23, 24, 31, 25, 41, 42, 43, 51, \n           44, 45, 61, 17, 18, 19, 71, 52),\n  name = c(\"Antalaha\", \"Antsirabe\", \"Marovoay\", \"Toliara coastal\", \"Antsohihy\", \n           \"Tsiroanomandidy\", \"Farafangana\", \"Ambovombe\", \n           \"Alaotra\", \"Manjakandriana\", \"Toliara North\", \n           \"Fenerive East\", \"Bekily\", \"Mahanoro\", \"Itasy\", \n           \"Menabe-Belo\", \"Fianarantsoa\", \"Tsivory\", \"Morondava\", \"Manandriana\", \n           \"Tanandava\", \"Ihosy\", \"Ambohimahasoa\", \"Manakara\", \"Tolanaro\", \n           \"Menabe North-East\"),\n  latitude = c(-14.8833, -19.8659, -16.1000, -23.7574, -14.8796, -18.7713, \n               -22.8167, -25.1667, -17.8319, -18.9167, -23.2941, -17.3500, \n               -24.6900, -19.9000, -19.1686, -19.6975, -21.4527, -24.4667, \n               -20.2833, -20.2333, -22.5711, -22.4000, -20.7145, -22.1333, \n               -25.0381, -20.5486),\n  longitude = c(50.2833, 47.0333, 46.6333, 43.6770, 47.9875, 46.0546, 47.8333, \n                46.0833, 48.4167, 47.8000, 43.7761, 49.4167, 45.1700, 48.8000,\n                46.7354, 44.5419, 47.0857, 45.4667, 44.2833, 47.3833, 45.0439, \n                46.1167, 47.0389, 48.0167, 46.9562, 47.1597))\n\nobs_count &lt;- left_join(obs_count, locations, by = c(\"observatory_name\" = \"name\"))\n\n\nmadagascar &lt;- st_read(paste0(\"data/Spatial_data/OCHA_BNGRC admin boundaries/\",\n                             \"mdg_admbnda_adm0_BNGRC_OCHA_20181031.shp\"),\n                      quiet = TRUE)\n\n# Sort locations by latitude to generate sequence numbers\nlocations &lt;- locations %&gt;%\n  arrange(desc(latitude)) %&gt;%\n  mutate(seq_num = 1:n())\n\n# Create map plot with labels\nmap_plot &lt;- ggplot(data = madagascar) +\n  geom_sf(fill = \"lightgray\", colour = \"dimgrey\") +\n  geom_point(data = locations, aes(x = longitude, y = latitude, color = name), \n             size = 3) +\n  geom_text(data = locations, aes(x = longitude, y = latitude, label = seq_num), \n            vjust = -1, hjust = 1, size = 3, # check_overlap = TRUE,\n            fontface = \"bold\") + \n  theme_void() +\n  theme(legend.position = \"none\")\n\n# Add sequence numbers to observatory names in obs_count dataframe\nobs_count &lt;- obs_count %&gt;%\n  left_join(locations %&gt;%\n              select(name, seq_num), \n            by = c(\"observatory_name\" = \"name\")) %&gt;%\n  mutate(observatory_with_num = paste0(seq_num, \". \", observatory_name))\n\n# Create timeline plot using modified obs_count with observatory_with_num\ntimeline_plot &lt;- ggplot(obs_count, \n                        aes(x = year, \n                            y = fct_reorder(observatory_with_num, latitude), \n                            color = observatory_name)) +\n  geom_point(aes(size = survey_count), show.legend = F) +\n  theme_minimal() +\n  labs(y = NULL, x = NULL) +\n  theme(axis.text.y = element_text(size = 8, face = \"bold\"),\n        legend.position = \"none\")\n\n# Stitch the plots together\ncombined_plot &lt;- plot_grid(map_plot, timeline_plot, rel_widths = c(1.3, 2))\n\nggsave(\"output/ROR_history.png\", plot = combined_plot, \n       width = 10, height = 7, dpi = 300)\n\nprint(combined_plot)\n\n\n\n\n\nFigure 1: Coarse location of rural observatory and survey years\n\n\n\n\nFigure 1 shows the coarse location of the 26 observatories composing the ROR, as well as the years in which data was collected in each one."
  },
  {
    "objectID": "01-ror-data-catalogue.html",
    "href": "01-ror-data-catalogue.html",
    "title": "1  Data catalogue",
    "section": "",
    "text": "The ROR survey data is organized in a collection of year-specfic folders ranging from 1995 to 2015. Each yearly folder houses multiple .dta files (Stata data format) – about 85 per year – with diverse filenames such as “res_as.dta” and “res_bp.dta”. The code block below creates a data dictionnary, which can be downloaded by clicking on this link.\n\n\nCode\nlibrary(tidyverse)    # A series of packages for data manipulation\nlibrary(haven)        # Required for reading STATA files (.dta)\nlibrary(labelled)     # To work with labelled data from STATA\nlibrary(writexl)      # Write data frames to Excel format\n\nror_data_loc &lt;- \"data/ROR_data/\"\n\n# Function to extract variable info for a given year and file\nextract_variable_info &lt;- function(year, file) {\n  \n  file_path &lt;- paste0(ror_data_loc, year, \"/\", file)\n  \n  if (!file.exists(file_path)) return(tibble())\n  \n  data &lt;- read_dta(file_path, n_max = 0)\n  \n  tibble(\n    file_name = file,\n    variable_name = names(data),\n    variable_label = var_label(data) %&gt;% as.character(),\n    year = year)\n}\n\n# Obtain all years from the directory structure\nyears &lt;- list.dirs(ror_data_loc, recursive = FALSE, full.names = FALSE)\n\n# Use the tidyverse approach to map over years and files\nall_vars &lt;- map_df(years, ~{\n  files_for_year &lt;- list.files(paste0(ror_data_loc, .x), pattern = \"\\\\.dta$\", full.names = FALSE)\n  map_df(files_for_year, extract_variable_info, year = .x)\n})\n\n# Convert any NULL values in variable_label to \"NA\"\nall_vars$variable_label[is.na(all_vars$variable_label)] &lt;- \"NA\"\n\n# Consolidate the information using the tidyverse approach\nvariable_dictionary &lt;- all_vars %&gt;%\n  group_by(file_name, variable_name) %&gt;%\n  arrange(year) %&gt;%  \n  summarise(\n    variable_label = first(variable_label[variable_label != \"NA\"] %||% \"NA\"),\n    years_present = list(unique(year))) %&gt;%\n  ungroup() %&gt;%\n  mutate(years_present = map_chr(years_present, ~ paste(.x, collapse = \",\")))\n\n# Write the variable dictionary to an Excel file\nwrite_xlsx(variable_dictionary, \"output/ROR_Variable_Dictionary.xlsx\")"
  },
  {
    "objectID": "03-ror-data-georeferencing.html",
    "href": "03-ror-data-georeferencing.html",
    "title": "3  Georeferencing the Rural Observatory Data",
    "section": "",
    "text": "This section details the georeferencing process applied to household panel data collected by the Rural Observatory Network (ROR) from 1995 to 2014. The ROR gathered data on various rural contexts in Madagascar. While the data quality was carefully monitored, its geolocation attributes were not fully developed, limiting its use in spatially integrated research and public policy evaluation. This appendix aligns the ROR dataset’s varied spatial denominations with a standardized geographic database, ensuring consistent correlation between each ROR observation and corresponding geospatial entities, namely communes and fokontany. Like in other sections of this document, the source code developed to perform all the data processing is accessible by unfolding the code blocks, like the one below.\n\n\nCode\nlibrary(tidyverse)    # A series of packages for data manipulation\nlibrary(haven)        # Required for reading STATA files (.dta)\nlibrary(labelled)     # To work with labelled data from STATA\nlibrary(sf)           # for spatial data handling\nlibrary(stringdist)   # for string distance and matching\nlibrary(tmap)         # for mapping\nlibrary(fuzzyjoin)    # for fuzzy joining\nlibrary(readxl)       # Read data frames to Excel format\nlibrary(writexl)      # Write data frames to Excel format\nlibrary(gt)           # for nicely formatted tables\nlibrary(cowplot)      # to combine plots\nlibrary(gtsummary)    # to produce nice summary tables\nlibrary(janitor)      # to simply add rowsums"
  },
  {
    "objectID": "03-ror-data-georeferencing.html#methodology",
    "href": "03-ror-data-georeferencing.html#methodology",
    "title": "3  Georeferencing the Rural Observatory Data",
    "section": "3.1 Methodology",
    "text": "3.1 Methodology\n\n3.1.1 Simplify strings\nThe treatment of toponyms presents a unique challenge, especially when these names are captured from varied sources. In the dataset, these names can vary due to differences in languages, case sensitivity, and the inclusion of additional descriptive terms. To address this, the clean_string function was developed. This function begins by converting all strings to lowercase, ensuring that subsequent comparisons are not sensitive to case variations. Next, to create a uniform standard, all non-alphanumeric characters are removed, retaining only spaces and the alphanumeric content. Common qualifiers in toponyms, such as “centre”, “haut” (high) or “bas” (low), which are not used consistently across records, are also removed. Given the bilingual nature of the dataset, with entries potentially in both Malagasy and French, the function translates cardinal points to the Malagasy language to ensure uniformity. Lastly, certain locales with multiple names, such as “Fort Dauphin”, also known as “Taolagnaro”, “Tolagnaro” or “Tolanaro”, are standardized to a single term, “Tolanaro”, to eliminate potential disparities. We also address instances of Roman numerals from I to VI, converting them to their Arabic numeral counterparts, ensuring consistent representation across records.\n\n\nCode\nclean_string &lt;- function(x){\n  x %&gt;%\n    tolower() %&gt;% # Convert to lowercase\n    # Retain spaces, remove other non-alphanumeric characters\n    str_replace_all(\"[^[:alnum:][:space:]]\", \" \") %&gt;% \n    str_remove_all(\"\\\\b(centre|haut|bas|androy)\\\\b\") %&gt;%\n    str_trim() %&gt;% # Trim spaces from start and end of string\n    str_replace_all(\"\\\\bcentre\\\\b\", \"\") %&gt;% # Remove the word 'centre'\n    # Translate cardinal points\n    str_replace_all(\"\\\\bnord\\\\b\", \"avaratra\") %&gt;% \n    str_replace_all(\"\\\\best\\\\b\", \"atsinanana\") %&gt;%\n    str_replace_all(\"\\\\bouest\\\\b\", \"andrefana\") %&gt;% \n    str_replace_all(\"\\\\bsud\\\\b\", \"atsimo\") %&gt;% \n    str_replace_all(\"\\\\batsinana\\\\b\", \"atsinanana\") %&gt;% # Replace short form \n    str_replace_all(\"(fort dauphin)|(taolagnaro)|(tolagnaro)\", \n                    \"tolanaro\") %&gt;% # Variations for fort dauphin\n    # Convert Roman numerals to Arabic\n    str_replace_all(\"\\\\bi\\\\b\", \"1\") %&gt;% \n    str_replace_all(\"\\\\bii\\\\b\", \"2\") %&gt;%\n    str_replace_all(\"\\\\biii\\\\b\", \"3\") %&gt;% \n    str_replace_all(\"\\\\biv\\\\b\", \"4\") %&gt;% \n    str_replace_all(\"\\\\bv\\\\b\", \"5\") %&gt;% \n    str_replace_all(\"\\\\bvi\\\\b\", \"6\")\n}\n\n\n\n\n3.1.2 Fuzzy matching\nBy default, statistical softwares and computing language match text by pairing only identical strings. Exact string matching is inappropriate in our context, where location data entry was subject to human errors like typographical mistakes or minor variations in spelling. To avoid this rigidity, fuzzy matching is employed. This approach gauges the degree of similarity between two strings, bypassing the need for an exact character-to-character match. The principle metric adopted for this is the “Levenshtein distance”, which quantifies the minimum number of single-character edits required to change one string into another. The fuzzy_match function encapsulates this approach. The function initiates the process by filtering the reference list of encontered toponyms based on a given observatory code, which considerably narrows down potential matches. Then, using the Jaro-Winkler distance metric — a variant of the Levenshtein distance particularly suited for shorter strings — the function computes the similarity between the target string and entries in the filtered reference. To ensure that only relevant matches are acknowledged, a threshold, termed max_distance, is set. Matches that exceed this threshold are disregarded. For those that pass this validation, the function then extracts the pertinent details of the matched row from the reference dataframe.\n\n\nCode\nfuzzy_match &lt;- function(target_string, dataframe, column_name, observatory_code, \n                        max_distance = 0.25) {\n  # Filter the dataframe based on observatory_code\n  filtered_reference &lt;- dataframe %&gt;%\n    filter(OBS_CODE == observatory_code) %&gt;%\n    select(all_of(column_name), ADM3_PCODE, ADM3_EN)\n  \n  # If filtered_reference is empty, return NA values\n  if (nrow(filtered_reference) == 0) {\n    return(list(matched_string = NA, ADM3_PCODE = NA, ADM3_EN = NA, distance = 1))\n  }\n  \n  # Use stringdist to find the closest match\n  distances &lt;- stringdist::stringdistmatrix(target_string, filtered_reference[[column_name]], method = \"jw\")\n  \n  # If there are no valid distances, set min_distance to Inf (this should help avoid the error)\n  if(all(is.na(distances))) {\n    min_distance &lt;- Inf\n  } else {\n    min_distance &lt;- min(distances, na.rm = TRUE)  # Ensure NA values don't affect the min calculation\n  }\n  \n  # Check for Inf distance and replace it with 1\n  if (is.infinite(min_distance)) {\n    min_distance &lt;- 1\n  }\n  \n  # If min_distance exceeds the max_distance threshold, return NA values\n  if (min_distance &gt; max_distance) {\n    return(list(matched_string = NA, ADM3_PCODE = NA, ADM3_EN = NA, distance = NA))\n  }\n  \n  matched_row &lt;- filtered_reference[which.min(distances), ]\n  \n  return(list(matched_string = matched_row[[column_name]], \n              ADM3_PCODE = matched_row$ADM3_PCODE, \n              ADM3_EN = matched_row$ADM3_EN, \n              distance = min_distance))\n}\n\n\n\n\n3.1.3 Hierarchical matching of data\nThe hierarchical organization of spatial entities is key for our challenge. Such an organization allows for a cascading representation of data, from broader scopes narrowing down to more specific layers. This representation is reminiscent of the defining order of geographical entities: regions contain provinces, which contain municipalities, and these in turn contain localities. In the georeferencing context, leveraging this hierarchical structure can lead to more precise matches. For instance, if an observatory code is associated with a specific district, the search for matches is confined to that district, enhancing both the efficiency and accuracy of the process. Figure 3.1 represents this hierarchical arrangement, serving as a roadmap for the subsequent data matching tasks.\n\n\n\n\ngraph TD\n\nA[Legend]\n\nW[ ]\nX[ ]\nY[ ]\nZ[ ]\n\nW --&gt;|Pre-definede hierarchy| X\nY -.-|Implemented matching|Z\n\n\n\n\n\n\n\n\n\n\ngraph TD\n\n%% Administrative Logic\nsubgraph \"Administrative Logic\"\nA[Region]\nB[District]\nC[Commune]\nD[Fokontany]\nI[Populated places]\n\nA --&gt; B\nB --&gt; C\nC --&gt; D\nD --&gt; I\nend\n\n%% Observatory Logic\n\nsubgraph \"Observatory Logic\"\nE[Observatory network]\nF[Observatory]\nG[Commune]\nH[Village]\nJ[Site]\n\nE --&gt; F\nF --&gt; G\nG --&gt; H\nF --&gt; H\nH--&gt; J\nend\n\n%% Geospatial matching\nH -.- I\nC -.- G\n\n\nFigure 3.1: Spatial entities pre-defined relationship and matching\n\n\n\n\nMadagascar’s current administrative setup is straightforward: regions contain districts; districts have communes; and communes are made up of Fokontany. Though a Fokontany should in principle be a single village, it often includes multiple villages or populated areas. It’s worth noting that while the idea of communes has been around for a while, they were only officially recognized in 1994. However, rolling them out took some time after 1994. Before 1994, “communes” simply described local government areas without any formal administrative status. The regions were created in 2004. On the ROR side, observatory refereed during the first surveys to villages. A systematic registry of the communes only started in the 2004 and 2005 round, depending on the observatories. A mention to “sites” also appeared in 2011 but was scarcely documented. Our strategy was to established links between the village information and populated places, and between communes."
  },
  {
    "objectID": "03-ror-data-georeferencing.html#a-detailed-walk-through",
    "href": "03-ror-data-georeferencing.html#a-detailed-walk-through",
    "title": "3  Georeferencing",
    "section": "3.3 A Detailed walk-through",
    "text": "3.3 A Detailed walk-through\nWe now break down our approach to describe each subsequent step. We began by exploring the ROR documentation, and in particular the reports associated to community survey, that contain descriptions of the area surveyed by each observatory. While doing so, we updated the COD subnational administrative boundary dataset by adding a field named OBS_Y_N. This field was marked as ‘1’ if the municipality was listed in an observatory survey; if not, it was left empty. Additionally, we added another field, OBS_NUM, which would store the observatory number. If the municipality wasn’t part of any survey, this field was left empty. The list of observatories and surveyed municipalities can be found in the Table 3.2.\nNext, we moved on to geolocation, which took place in four stages. Each stage depended heavily on the data quality and completeness obtained from the previous ones.\n\n3.3.1 Method 1\nThis phase entailed a systematic alignment process for the municipalities. When municipality names were included in our dataset, an attempt was made to correlate them with names of municipalities identified as data collection locales. For enhanced precision, this alignment was conducted specific to each observatory. Given the potential for variance in nomenclature across sources, a fuzzy matching algorithm was employed. This method calculates the probability of two distinct names referencing the same entity. Upon identifying a probable match, we performed a visual verification for all matches and flagged the false positives to remove them.\nThe following code segment elucidates the methodology applied:\n\n\nCode\n# List of years\nyears &lt;- 1995:2014\n\n# Read all datasets and combine\nall_surveys_description &lt;- map_df(years, function(year) {\n  df &lt;- read_dta(paste0(ror_data_loc, year, \"/res_deb.dta\"))\n    # Convert all columns to character to ensure consistency\n  df &lt;- df %&gt;% mutate_all(as.character)\n  return(df)\n})\n\n# Extract unique combinations and list all the years they appeared in\nunique_combinations &lt;- all_surveys_description %&gt;%\n  group_by(j0, j42, j4) %&gt;%\n  summarize(years = toString(unique(year)),\n            obs_count = n()) %&gt;%\n  ungroup()\n\n# Harmonize the fields that contain municipality or village names\nunique_combinations &lt;- unique_combinations %&gt;%\n  mutate(clean_muni = clean_string(j42),\n         clean_village = clean_string(j4))\nobs_communes &lt;- obs_communes %&gt;%\n  mutate(clean_ADM3 = clean_string(ADM3_EN))\npop_places &lt;- pop_places %&gt;%\n  mutate(clean_pname = clean_string(PLACE_NAME)) \n\n# List of observatories for which municipalities have been identified\nidentified_observatories &lt;- unique(obs_communes$OBS_CODE) %&gt;%\n  na.omit()\n# Filter for the observatory for which we already have a manual identification\n# of municipalities\nunique_combinations &lt;- unique_combinations %&gt;%\n  filter(j0 %in% identified_observatories) \n\n# Apply the fuzzy matching observatory-wise\nresults &lt;- map2_df(unique_combinations$clean_muni, \n                   unique_combinations$j0, \n                   ~ as.data.frame(t(\n                     fuzzy_match(.x, obs_communes, \"clean_ADM3\", .y))))  %&gt;%\n  unnest(cols = c(matched_string, distance, ADM3_PCODE, ADM3_EN))\n\n# Combine the results with the unique_combinations\ncorrespondence_table &lt;- bind_cols(unique_combinations, results) \n\n# Add a column for the matching method\ncorrespondence_table &lt;- correspondence_table %&gt;%\n  mutate(method = ifelse(!is.na(matched_string), \"method_1\", NA_character_))\n\n\nTo synthesize and visually represent our matches, the identified municipalities are plotted on a map:\n\n\nCode\n# Extract matched resuts\nmatched_results &lt;- unique(correspondence_table$ADM3_PCODE) %&gt;%\n  na.omit()\n# Keep municipalities in those\nmatched_spatial &lt;- obs_communes %&gt;%\n  filter(ADM3_PCODE %in% matched_results)\n\ntmap_mode(\"view\")\n# Plot\ntm_shape(matched_spatial) +\n  tm_polygons(col = \"OBS_NAME\")\n\n\n\n\n\n\n\n\n\n3.3.2 Method 2: Extracting municipality names from text in “village names”\nFor observations where the field “municipality name” was empty (all cases before 2004 and still a frequent situation afterwards), we turned our attention to the village name field. The objective was to decipher whether these village names could potentially contain a municipality’s name that had been previously pinpointed during the observatory surveys. For the observations with no municipality value, we teased out the first word or segment in the village name. This extracted word then underwent a process of fuzzy matching against the roster of identified municipalities’ names. However, manual verification spotted errors. Certain matches, which we labeled ‘false positives’, emerged as errors and were purged from the results. Once this cleansing step was concluded, we included the validated matches back into the primary correspondence table.\n\n\nCode\n# Filter out matched municipalities and extract the first word\nunmatched_results &lt;- correspondence_table %&gt;%\n  filter(is.na(matched_string)) %&gt;%\n  select(j0:clean_village) %&gt;%\n  mutate(first_word = str_extract(clean_village, \"^[^\\\\s/]+\"))\n\n# Fuzzy matching with the first word and identified municipalities\nresults_step2 &lt;- map2_df(unmatched_results$first_word, \n                         unmatched_results$j0, \n                         ~ as.data.frame(t(\n                           fuzzy_match(.x, obs_communes, \"clean_ADM3\", .y))))  %&gt;%\n  unnest(cols = c(matched_string, distance, ADM3_PCODE, ADM3_EN))\n\n# Update Results\npotential_matches2 &lt;- bind_cols(unmatched_results, results_step2)\n\n# Manually identify false positives and remove them\nfalse_positives &lt;- c(\"madiromionga\", \"maroarla\", \"tsaratanteraka\", \n                    \"ambatoharanana\", \"ambatoaranana\", \"maroala\", \"erakoja\", \n                    \"erakoka\", \"maroalo\", \"erakka\", \"erakoa\")\nvalidated_matches2 &lt;- potential_matches2 %&gt;%\n  mutate(across(c(matched_string, ADM3_PCODE, ADM3_EN, distance),\n               ~ ifelse(first_word %in% false_positives, NA, .)),\n         method = ifelse(!is.na(matched_string), \"method_2\", NA_character_))\n\n# Integrate new results in correspondence table\ncorrespondence_table &lt;- correspondence_table %&gt;%\n  filter(!is.na(matched_string)) %&gt;%\n  bind_rows(validated_matches2) %&gt;%\n  select(-first_word)\n\n\n\n\n3.3.3 Method 3: Village name fuzzy matching with populated places\nWith some observations still devoid of a matched municipality, we initiated another processing layer. This phase saw the unmatched village names being subjected to fuzzy matching against the populated places dataset described above. We first sifted out the unmatched results from our prior analysis. Then, we augmented the ‘pop_places’ dataset with observatory codes for the entries that were located in communes recognized as surveyed by observatories. Next we performed another fuzzy matching, comparing the village names against the ‘pop_places’ names. To maintain a level of precision, we set a restrictive threshold, dismissing any match that exceeded a certain “distance” or degree of difference. But, as with the previous methods, visual verification revealed some missmatches. These ‘false positives’ were flagged and discarded and the remaining ones were integrated into the overarching correspondence table.\n\n\nCode\n# Re-filter unmatched results\nunmatched_results2 &lt;- correspondence_table %&gt;%\n  filter(is.na(matched_string)) %&gt;%\n  select(j0:clean_village)\n\n# Join OBS_CODE to pop_places\npop_places &lt;- pop_places %&gt;%\n  rename(ADM3_PCODE = COM_PCODE, ADM3_EN = COMMUNE) %&gt;%\n  mutate(ADM3_PCODE = str_replace(ADM3_PCODE, \"^MDG\", \"MG\")) %&gt;%\n  left_join(select(obs_communes, ADM3_PCODE, OBS_CODE) %&gt;%\n                     st_drop_geometry(), \n            by = \"ADM3_PCODE\")\n\n# Apply the fuzzy matching observatory-wise\nresults_step3 &lt;- map2_df(unmatched_results2$clean_village, \n                         unmatched_results2$j0, \n                         ~ as.data.frame(t(\n                           fuzzy_match(.x, pop_places, \"clean_pname\", .y,\n                                       max_distance = 0.22))))  %&gt;% # erratic results beyond\n  unnest(cols = c(matched_string, distance, ADM3_PCODE, ADM3_EN))\n\n# Bind the results with unmatched_results_v2\npotential_matches3 &lt;- bind_cols(unmatched_results2, results_step3)\n\n# Manually identify false positives and remove them\nfalse_positives2 &lt;- c(\"analambarika\", \"maroaloka\", \"ambakela\", \"ambodirofia\",\n                      \"ambohibao\", \"ambato mangabe\", \"marofonaritra\", \n                      \"andranovo ambodimanga\", \"morataitra\", \"antanambao\", \n                      \"ankililoa\")\nvalidated_matches3 &lt;- potential_matches3 %&gt;%\n  mutate(across(c(matched_string, ADM3_PCODE, ADM3_EN, distance),\n               ~ ifelse(clean_village %in% false_positives2, NA, .)),\n         method = ifelse(!is.na(matched_string), \"method_3\", NA_character_))\n\ncorrespondence_table &lt;- correspondence_table %&gt;%\n  filter(!is.na(matched_string)) %&gt;%\n  bind_rows(validated_matches3)\n\n\n\n\n3.3.4 Method 4\nFor the remaining, let’s try matching with other village names for which municipality has been matched.\nEven after the above measures, there remained observations that had eluded a municipality match. The subsequent strategy was to juxtapose them with other village names that had already been successfully matched to a municipality. We assembled a dataset comprising of municipality names and their paired village names, using data from previous successful matches. UThen the still-unmatched village names were run through a fuzzy matching process against the known village names. We fine-tuned the algorithm with a restrictive matching threshold. Again, some matches stood out as anomalies. Labeled as ‘false positives’, these were sifted out and the newly matched data was incorporated into the main correspondence table.\n\n\nCode\n# Create a list of municipality names and village names for matched observations\nmatched_villages &lt;- correspondence_table %&gt;%\n  filter(!is.na(method)) %&gt;%\n  select(j0, ADM3_PCODE, ADM3_EN, clean_village) %&gt;%\n  distinct() %&gt;%\n  rename(OBS_CODE = j0)\n\n# Re-filter unmatched results\nunmatched_results3 &lt;- correspondence_table %&gt;%\n  filter(is.na(method)) %&gt;%\n  select(j0:clean_village)\n\n# Try matching unmatched villages against matched village names observatory-wise\nresults_village_match &lt;- map2_df(\n  unmatched_results3$clean_village, unmatched_results3$j0,\n  ~ as.data.frame(t(fuzzy_match(.x, matched_villages, \"clean_village\",\n                                .y, max_distance = 0.28)))) %&gt;%\n  unnest(cols = c(matched_string, distance, ADM3_PCODE, ADM3_EN))\n# Bind these results with unmatched_results_v3\npotential_matches4 &lt;- bind_cols(unmatched_results3, results_village_match)\n\n# Manually identify false positives and remove them\nfalse_positives4 &lt;- c(\"amp0mbibitika antanakova\", \"arakoke ambonano ampihamibe\", \n                      \"farara farara\", \"farara ambakela\", \"fara ambakela\", \n                      \"ambatotelo marofinaritra\")\nvalidated_matches4 &lt;- potential_matches4 %&gt;%\n  mutate(across(c(matched_string, ADM3_PCODE, ADM3_EN, distance),\n               ~ ifelse(clean_village %in% false_positives4, NA, .)),\n         method = ifelse(!is.na(matched_string), \"method_4\", NA_character_))\n\n\n# Merge the updated results back to the correspondence table\ncorrespondence_table &lt;- correspondence_table %&gt;%\n  filter(!is.na(matched_string)) %&gt;%\n  bind_rows(validated_matches4)"
  },
  {
    "objectID": "03-ror-data-georeferencing.html#matching-villages",
    "href": "03-ror-data-georeferencing.html#matching-villages",
    "title": "3  Georeferencing",
    "section": "3.4 Matching villages",
    "text": "3.4 Matching villages\nAfter successfully matching commune names with an official, normalized reference, our next goal is to align the villages as identified by the ROR with their administrative counterpart, known as Fokontany. This task presents challenges, notably because the ROR’s village identifications weren’t directly linked to Fokontany names, and the Fokontany names themselves have undergone changes. Additionally, variations in village naming within the ROR dataset complicate the process. Our approach involves several steps: First, we load the official COD Fokontany dataset. Next, we standardize the place names using our previously discussed clean_string function. Then, using the purpose-built fuzzy_match_village function, we assess the similarity between the village names in the ROR dataset and the Fokontany names within the same commune, specifically by calculating the Jaro-Winkler distance between the strings. We the names with the highest degree of matching. During a manual review of these results, we closely examined the matches, especially those with larger Jaro-Winkler distance. From this examination, we derived a distance of 0.2, below which the majority of matches were accurate. Notably, some matches above this threshold were deemed accurate and retained, while a small number of matches below this threshold were identified as false positives and subsequently discarded.\n\n\nCode\n# Load the ADM4 dataset, which corresponds to Fokontany\nfokontany &lt;- st_read(\"data/Spatial_data/OCHA_BNGRC admin boundaries/mdg_admbnda_adm4_BNGRC_OCHA_20181031.shp\",\n                      quiet = TRUE) %&gt;%\n  mutate(ADM4_clean = clean_string(ADM4_EN))\n\n# A function to perform fuzzy matching with Fokontany or populated places\nfuzzy_match_village &lt;- function(target_string, dataframe, column_name, \n                                ADM3_PCODE_filter, id_column, \n                                municipality_string = NULL, max_distance = 0.4) {\n  \n  # Check if target_string has multiple words and if the first word matches the municipality_string\n  if (!is.null(municipality_string) && length(unlist(strsplit(target_string, \" \"))) &gt; 1) {\n    first_word &lt;- unlist(strsplit(target_string, \" \"))[1]\n    distances_municipality &lt;- stringdist::stringdist(first_word, municipality_string, method = \"jw\")\n    if (min(distances_municipality, na.rm = TRUE) &lt;= max_distance) {\n      target_string &lt;- str_remove(target_string, paste0(\"^\", first_word, \" \"))\n    }\n  }\n  \n  filtered_reference &lt;- dataframe %&gt;%\n                          filter(ADM3_PCODE == ADM3_PCODE_filter) %&gt;%\n                          select(all_of(column_name), all_of(id_column))\n  \n  # If filtered_reference is empty, return NA values\n  if (nrow(filtered_reference) == 0) {\n    return(list(matched_string = NA, ID = NA, geometry = NA, distance = 1))\n  }\n  \n  # Use stringdist to find the closest match\n  distances &lt;- stringdist::stringdistmatrix(\n    target_string, filtered_reference[[column_name]], method = \"jw\")\n  \n  # If there are no valid distances, set min_distance to Inf\n  if(all(is.na(distances))) {\n    min_distance &lt;- Inf\n  } else {\n    min_distance &lt;- min(distances, na.rm = TRUE)\n  }\n  \n  # Check for Inf distance and replace it with 1\n  if (is.infinite(min_distance)) {\n    min_distance &lt;- 1\n  }\n  \n  # If min_distance exceeds the max_distance threshold, return NA values\n  if (min_distance &gt; max_distance) {\n    return(list(matched_string = NA, ID = NA, geometry = NA, \n                distance = NA))\n  }\n  \n  matched_row &lt;- filtered_reference[which.min(distances), ]\n  \n  return(list(matched_string = matched_row[[column_name]], \n              ID = matched_row[[id_column]], \n              distance = min_distance))\n}\n# correspondence table without municipality geometry\ncorrespondence_table2 &lt;- correspondence_table %&gt;%\n  st_drop_geometry()\n\n# For fokontany\nresults_fokontany &lt;- pmap_df(\n  list(clean_village = correspondence_table2$clean_village, \n       ADM3_PCODE = correspondence_table2$ADM3_PCODE, \n       municipality_string = correspondence_table2$clean_muni),\n  function(clean_village, ADM3_PCODE, municipality_string) {\n    as.data.frame(t(fuzzy_match_village(clean_village, fokontany, \n                                        \"ADM4_clean\", ADM3_PCODE, \"ADM4_PCODE\", municipality_string)))\n  }\n) %&gt;%\n   unnest(cols = everything()) %&gt;%\n  rename(ADM4_PCODE = ID, ADM4_clean = matched_string, distance2 = distance) %&gt;%\n  st_drop_geometry() %&gt;%\n  select(-geometry)\n \n# Combine the results with correspondence_table\ncorrespondence_table2_updated &lt;- bind_cols(correspondence_table2, \n                                          results_fokontany) %&gt;%\n  mutate(method_village = ifelse(!is.na(ADM4_PCODE), \"method_5\", NA_character_))\n\n\n# For a visual validation\ncorrespondence_table2_updated %&gt;% \n  arrange(desc(distance2)) %&gt;%\n  write_xlsx(\"correspondence_table2_update.xlsx\")\n\n# After instpecting the data, we find that a 0.2 threshold in distance is \n# appropriate. However some valid matches above this threshold should be kept\n\nhigh_tolerance_valid_matches &lt;- c(\n  \"ambanja\", \"ambararata 2\", \"ambaro\", \"ambatoharanana\", \"ambatomanga\", \n  \"ambazoamazava\", \"ambazoamirafy\", \"ambodibonara\", \"ambodimotso atsimo\", \n  \"ambohidrony\", \"ambohimahatsinjo atsinanana\", \"ambongabe\", \"amparafaravola\", \n  \"ampasy\", \"ampijoroa\", \"ampijoroan ala\", \"ampitana\", \"analambarika\", \n  \"andohasoamahainty\", \"anjiamangirana 1\", \"ankazoabo anivo\", \"ankerereake\", \n  \"ankililoaka 2\", \"bepako\", \"bevato\", \"erada 2\", \"esanta fototra\", \n  \"esanta marofoty\", \"esanta maromainty\", \"feramanga atsimo\", \"habohabo atsimo\", \n  \"habohabo avaratra\", \"lafiatsinanana\", \"madiromiongana\", \"manambaro 2\", \n  \"manantenina\", \"mangabe\", \"mangaoka\", \"maritampona\", \"maroala\", \"marofoty\", \n  \"marolampy\", \"marovantaza\", \"miary\", \"miary ankasy\", \"miary ankoronga\", \n  \"miorimivalana\", \"tanambao\", \"tanambao 2\", \"tandroka andrefana\", \n  \"tsarahasina\", \"vohilengo\")\n\n# Below this threshold, a few false positives should be removed\nlow_tolerance_invalid_marches &lt;- c(\n  \"AMBOHIMAHATSINJO EST\", \"AMBOHIMAHATSINJO-EST/CENTRE\", \n  \"AMBALAKINDRESY/ANDOHARENINA\", \"ambazoa /ampiha\", \"AMBALAKINDRESY/ANDOHARENA\", \n  \"ANKAZOABO SUD/ALAMBARIKE\", \"ANKARINEZAKA/NAMARINA\", \"AMBALA/ANDRANOLAVA\", \n  \"AMBALAKINDRESY/ANDRANOLAVA\", \"AMBALAKINDRESY/ANDRANOLAVA\")\n\ncorrespondence_table3 &lt;- correspondence_table2_updated %&gt;%\n  mutate(\n    across(c(ADM4_clean, ADM4_PCODE, distance2, method_village), \n           ~ case_when(\n             (distance2 &gt; 0.2 & !ADM4_clean %in% high_tolerance_valid_matches) |\n             ADM4_clean %in% low_tolerance_invalid_marches ~ NA,\n             TRUE ~ .)))"
  },
  {
    "objectID": "03-ror-data-georeferencing.html#validating-the-quality-of-georeferenced-data",
    "href": "03-ror-data-georeferencing.html#validating-the-quality-of-georeferenced-data",
    "title": "3  Georeferencing",
    "section": "3.5 Validating the Quality of Georeferenced Data",
    "text": "3.5 Validating the Quality of Georeferenced Data\nTo ensure the robustness and validity of our georeferenced data, we employ a multi-tiered validation approach that hinges on quantitative metrics and qualitative consistency checks.\n\n3.5.1 Quantitative metrics\nWe first look at the distribution of the unique observations that were successfully matched during the various stages of the georeferencing process.\n\n\nCode\n# Re-format modality labels  \nmatching_tbl &lt;- correspondence_table3 %&gt;%\n  mutate(method = case_when(\n    method == \"method_1\" ~ \"Method 1\",\n    method == \"method_2\" ~ \"Method 2\",\n    method == \"method_3\" ~ \"Method 3\",\n    method == \"method_4\" ~ \"Method 4\",\n    is.na(method) ~ \"Unmatched communes\"),\n    method_village = case_when(\n      method_village == \"method_5\" ~ \"Matched villages\",\n      is.na(method_village) ~ \"Unmatched villages\"))\n\nsummarized_data &lt;- matching_tbl %&gt;%\n  group_by(method, method_village) %&gt;%\n  summarize(total_obs = sum(obs_count, na.rm = TRUE)) %&gt;%\n  ungroup() %&gt;%\n  mutate(percent_obs = total_obs/sum(total_obs))\n\ncount_tbl &lt;- summarized_data %&gt;%\n  select(method, method_village, total_obs) %&gt;%\n  pivot_wider(names_from = method_village, values_from = total_obs, \n              values_fill = 0) %&gt;%\n  rowwise() %&gt;%\n  mutate(Total = sum(c(`Matched villages`, `Unmatched villages`))) %&gt;%\n  ungroup()  %&gt;%\n  adorn_totals(\"row\")\n\npercent_tbl &lt;- summarized_data %&gt;%\n  select(method, method_village, percent_obs) %&gt;%\n  pivot_wider(names_from = method_village, values_from = percent_obs, \n              values_fill = 0) %&gt;%\n  rowwise() %&gt;%\n  mutate(`Total (%)` = sum(c(`Matched villages`, `Unmatched villages`))) %&gt;%\n  ungroup() %&gt;%\n  rename(`Matched (%)` = `Matched villages`, \n         `Unmatched (%)` = `Unmatched villages`) %&gt;%\n  mutate(across(where(is.numeric), ~ round(.x * 100, 2))) %&gt;%\n  adorn_totals(\"row\")\n\n\nsummarized_data &lt;- count_tbl %&gt;%\n  left_join(percent_tbl, by = \"method\") %&gt;%\n  relocate(method, `Matched villages`, `Matched (%)`, \n           `Unmatched villages`, `Unmatched (%)`,\n           Total, `Total (%)`) %&gt;%\n  rename(`Commune matching method` = method)\n\ngt(summarized_data)  %&gt;%\n  # Add a title\n  tab_header(title = \"Result of matching process\",\n             subtitle = \"Number of survey observation per method\") \n\n\n\n\n\n\nTable 3.1:  Number of ROR observation which commune and village were matched \n  \n    \n      Result of matching process\n    \n    \n      Number of survey observation per method\n    \n    \n      Commune matching method\n      Matched villages\n      Matched (%)\n      Unmatched villages\n      Unmatched (%)\n      Total\n      Total (%)\n    \n  \n  \n    Method 1\n30925\n30.69\n12605\n12.51\n43530\n43.20\n    Method 2\n16491\n16.37\n6727\n6.68\n23218\n23.04\n    Method 3\n10723\n10.64\n4006\n3.98\n14729\n14.62\n    Method 4\n3843\n3.81\n7198\n7.14\n11041\n10.96\n    Unmatched communes\n0\n0.00\n8237\n8.18\n8237\n8.18\n    Total\n61982\n61.51\n38773\n38.49\n100755\n100.00\n  \n  \n  \n\n\n\n\n\n\n\n3.5.2 Consistency check with documentation\nTo ensure the comprehensiveness of our georeferencing process, we summarize the list of unique matches for villages from all the municipalities in the final dataset. This check will help ensure there are no glaring gaps in the matched data.\n\n\nCode\nfokontany_list &lt;- correspondence_table3 %&gt;%\n  mutate(j0 = as.numeric(j0)) %&gt;%\n  left_join(observatory_names, by = c(\"j0\" = \"code\")) %&gt;%\n  rename(OBS_NAME = name) %&gt;%\n  left_join(select(st_drop_geometry(fokontany), ADM4_PCODE, ADM4_EN),\n            by = \"ADM4_PCODE\") %&gt;%\n  group_by(OBS_NAME, ADM3_EN) %&gt;%\n  summarize(ADM4_EN = list(unique(if_else(is.na(ADM4_EN), \"Unknown\", ADM4_EN)))) %&gt;%\n  ungroup() %&gt;%\n  mutate(ADM4_EN = map_chr(ADM4_EN, ~ str_c(.x, collapse = \", \")))\n\nfokontany_list %&gt;%\n  gt() %&gt;%\n  # Set column labels\n  cols_label(\n    OBS_NAME = \"Observatory Name\",\n    ADM3_EN = \"Commune Name\",\n    ADM4_EN = \"Fokontany Names\") %&gt;%\n  # Add a title\n  tab_header(title = \"Summary of Fokontany List\",\n             subtitle = \"Breakdown by Observatory and Commune\") \n\n\n\n\n\n\nTable 3.2:  List of fokontany per commune and observatory \n  \n    \n      Summary of Fokontany List\n    \n    \n      Breakdown by Observatory and Commune\n    \n    \n      Observatory Name\n      Commune Name\n      Fokontany Names\n    \n  \n  \n    Alaotra\nAmbatondrazaka Suburbaine\nUnknown, Ambongabe\n    Alaotra\nAmparafaravola\nUnknown, Ambodimanga, Amparafaravola, Ampasimbola, Analamiranga, Maritampona, Ambondrona\n    Alaotra\nFeramanga Nord\nUnknown, Avaradrano\n    Alaotra\nIlafy\nFeramanga Atsimo, Unknown, Mangabe, Marianina\n    Alaotra\nMorarano Chrome\nUnknown, Ambatomanga, Ambohidrony, Ambodiatafana, Ambodirano\n    Alaotra\nNA\nUnknown\n    Ambohimahasoa\nAmbalakindresy\nAntsiho, Unknown, Ambohimahatsinjo Est, Ankarinezaka, Andraina, Ambatofolaka\n    Ambohimahasoa\nAmpitana\nAmpitana, Andoharondra, Andohasoamahainty, Unknown, Ambalavola\n    Ambovombe\nAmbanisarika\nMarofoty, Ambanisarika, Ambolimoka, Unknown\n    Ambovombe\nAmbazoa\nAmbazoa II, Ambazoa I, Ampiha, Ambazoamazava, Ampaipaika, Halomboro\n    Ambovombe\nAmbonaivo\nNagnalo, Beratro I, Beratro II, Unknown\n    Ambovombe\nAmbovombe\nAmbazoamirafy, Ambaro, Amboasary II, Unknown, Esanta Marofoty, Esanta Maromainty, Esanta Fototra, Bevato, Esanta IIi\n    Ambovombe\nErada\nErada II, Habohabo Sud, Unknown, Erada IIi, Habohabo Nord, Erada I\n    Ambovombe\nNA\nUnknown\n    Antalaha\nAmbinanifaho\nAmbinanifaho\n    Antalaha\nAmbodiampana\nUnknown, Manakana, Lohanantsahabe\n    Antalaha\nAmpohibe\nAmpohibe, Namohana\n    Antalaha\nAnjinjaomby\nAnjinjaomby\n    Antalaha\nAntombana\nMaromandia, Antombana, Unknown, Marovany\n    Antalaha\nAntsirabe Nord\nUnknown, Tsarahitra\n    Antalaha\nNA\nUnknown\n    Antsirabe\nAmbano\nUnknown, Andrakodavaka, Tsarafara, Antanetibe, Manampisoa, Tsarafiraisana\n    Antsirabe\nFaravohitra\nFaravohitra, Unknown, Fenomanantsoa\n    Antsirabe\nNA\nUnknown\n    Antsohihy\nAmbararata\nAmbararata II\n    Antsohihy\nAmbatosia\nUnknown, Ambatosia\n    Antsohihy\nAmbodimotso Sud\nAmbodimotso Sud, Marolampy Bas\n    Antsohihy\nAnjiamangirana\nAnjiamangirana I, Ambodimanga I, Ambohimarina\n    Antsohihy\nAnkerika\nAnkerika Centre, Ankerika Nord, Ankerika Sud\n    Antsohihy\nMarovantaza\nMarovantaza, Mangaoka\n    Antsohihy\nTsarahasina\nTsarahasina, Unknown, Besisika\n    Antsohihy\nNA\nUnknown\n    Bekily\nAntsakoamaro\nUnknown, Antsakoamaro, Ankilimihamy, Beparo\n    Bekily\nBekitro\nUnknown, Ankaboa, Ankilimiary, Marokily, Marosakoa, Miary Haut, Beangily, Manambahy I\n    Bekily\nBesakoa\nUnknown, Besakoa Centre\n    Bekily\nMaroviro\nUnknown\n    Bekily\nVohimanga\nVohimanga II, Unknown\n    Bekily\nNA\nUnknown\n    Farafangana\nAmbohigogo\nAmbohigogo, Ambalabe, Unknown, Esatra, Ambohimary, Anivorano, Lohatranambo\n    Farafangana\nAnilobe\nAmbohimahasoa, Unknown, Anilobe, Morarano, Morafeno II, Vohimalaza\n    Farafangana\nMahatsinjo\nAmpataka, Unknown, Mahatsinjo, Andranomavo\n    Farafangana\nVohilengo\nAnambotaka, Unknown, Vohilengo, Kazoaraka, Varary, Ambodimanara\n    Farafangana\nVohimasy\nUnknown, Vohimasy, Iandraina, Tsararano\n    Farafangana\nVohitromby\nUnknown, Vohitromby, Mahabo Ambany, Vohilava, Andranoboaka\n    Farafangana\nNA\nUnknown\n    Fenerive East\nAmbatoharanana\nUnknown, Ambodihazinina, Ambatoharanana, Ambohimanarivo\n    Fenerive East\nAmpasimbe Manantsatrana\nAmbodisatrana, Ambanja, Unknown, Ambodibonara\n    Fenerive East\nAmpasina Maningory\nUnknown, Amboditononona, Tanambao I, Andapabe, Ambatomitrozona\n    Fenerive East\nMiorimivalana\nMiorimivalana, Unknown\n    Fenerive East\nVohilengo\nVohilengo, Vohipenohely, Unknown\n    Fenerive East\nNA\nUnknown\n    Fianarantsoa\nAlatsinainy Ialamarina\nAlatsinainy Ialamarina, Todiana, Unknown\n    Fianarantsoa\nNA\nUnknown\n    Ihosy\nAnkily\nAnadabo, Ampandratokana, Unknown, Vatobe\n    Ihosy\nMaropaika\nMaropaika, Unknown, Amboza, Ampatsinakoho\n    Ihosy\nRanotsara Nord\nUnknown, Bekatra Tsarahonenana, Ranotsarabe, Andranombao, Ranotsara Nord\n    Itasy\nAmpary\nUnknown, Ambodifarihy, Ampary\n    Itasy\nAnosibe Ifanja\nUnknown, Ampahimanga\n    Itasy\nAntanetibe\nUnknown, Antanetibe\n    Itasy\nArivonimamo II\nUnknown, Amby, Antanetikely\n    Itasy\nMananasy\nUnknown, Manjakasoa, Ambohimitrena, Andranomafana, Tsitakondaza\n    Itasy\nMiarinarivo II\nUnknown, Ampasamanantongotra, Antanety\n    Itasy\nSoavinandriana\nMiavotra, Ambohidanerana, Unknown, Ambohitraivo, Soavinandriana Ambony, Ambohimiarintsoa, Tsinjovary Andrefana\n    Itasy\nNA\nUnknown\n    Mahanoro\nAmbodiharina\nUnknown, Ambodiharina\n    Mahanoro\nMasomeloka\nUnknown, Masomeloka, Ambodisana, Tanambao Soketaka, Antaniambo\n    Mahanoro\nTsaravinany\nUnknown, Ampitakihosy\n    Mahanoro\nNA\nUnknown\n    Manakara\nAmbandrika\nAmbandrika, Unknown\n    Manakara\nAmborondra\nUnknown, Amborondra, Anivorano, Anaviavimasina\n    Manakara\nIvato\nTanandava, Ivato\n    Manakara\nMarokarima\nUnknown, Marokarima, Antanjona, Maromandia\n    Manandriana\nAnjoman'ankona\nAmbatomikatsaka, Unknown, Fizinana, Ambero, Anjoman'ankona, Antamboholehibe\n    Manandriana\nNA\nUnknown\n    Manjakandriana\nAnjepy\nAnjepy\n    Manjakandriana\nMiadanandriana\nUnknown, Ambohipeno, Ambodifahitra, Ambohitsoabe, Ambohijanaka, Ambohitrombalahy\n    Manjakandriana\nNA\nUnknown\n    Marovoay\nAnkazomborona\nMadiromiongana, Unknown\n    Marovoay\nAntanimasaka\nMaroala, Ampijoroa\n    Marovoay\nMarovoay\nUnknown, Ampijoroan'ala\n    Marovoay\nTsararano\nUnknown, Bepako\n    Marovoay\nNA\nUnknown\n    Menabe North-East\nAmbatolahy\nAnkazoambo, Ankotrofotsy Mahasoa, Unknown\n    Menabe North-East\nAnkilizato\nUnknown, Filanjara\n    Menabe North-East\nAntsoha\nAnkarena\n    Menabe North-East\nIsalo\nAnalambiby, Bepeha, Soatanana Morlot\n    Menabe North-East\nMalaimbandy\nUnknown\n    Menabe North-East\nNA\nUnknown\n    Menabe-Belo\nTsaraotana\nAndranomandeha\n    Menabe-Belo\nTsimafana\nTsianaloka, Tsimafana, Unknown, Kiboy\n    Morondava\nAmpanihy\nAmpanihy, Unknown, Anjatelo, Ankilimida, Mananjaka, Vangoroka\n    Morondava\nAnkilivalo\nBezezika, Unknown, Tanambao I, Ankilivalo\n    Morondava\nBefasy\nUnknown, Andranomamy, Befasy, Misokitse\n    Tanandava\nAmbahikily\nUnknown, Namatoa, Tanandava Village, Tsianihy, Tanandava Station, Antanivao Tsaramandroso, Tongoarahamba\n    Tanandava\nNA\nUnknown\n    Tolanaro\nAmpasy Nahampoana\nUnknown, Ampasy Centre\n    Tolanaro\nEnakara-Haut\nUnknown, Enakara Haut\n    Tolanaro\nFort-Dauphin\nAmbinanibe, Unknown\n    Tolanaro\nMahatalaky\nUnknown\n    Tolanaro\nManambaro\nManambaro I, Unknown, Manambaro II\n    Tolanaro\nManantenina\nManantenina Haut, Unknown\n    Tolanaro\nMandromondromotra\nMandromondromotra, Hovatraha, Unknown\n    Tolanaro\nRanopiso\nRanopiso, Unknown\n    Tolanaro\nSoanierana\nLafiatsinanana, Unknown, Andranara\n    Toliara North\nAnkazoabo Sud\nAnalambarika, Unknown, Ankerereake, Atsimon-Dalana, Ankazoabo Anivo, Miary Centre, Tanambao II, Tandroka Ouest\n    Toliara North\nAnkililoaka\nTanambao, Ambondro, Ampagnolora, Unknown, Ankililoaka II\n    Toliara North\nMiary Ambohibola\nMiary Ankoronga, Unknown, Miary Ankasy\n    Toliara North\nNA\nUnknown\n    Toliara coastal\nBeheloka\nBeheloka Bas, Unknown, Besambay\n    Toliara coastal\nItampolo\nItampolo, Unknown, Berovontsy, Andranomasintsoa, Ankazoabo Nord, Malangeriake, Nisoa, Tanindranto, Zoenarivo\n    Toliara coastal\nNA\nUnknown\n    Tsiroanomandidy\nAmbalanirana\nUnknown, Ambatomavo\n    Tsiroanomandidy\nAmbararatabe\nAmbararatabe\n    Tsiroanomandidy\nAnkadinondry Sakay\nUnknown, Ankadinondry I, Ankadinondrikely, Ankadinondry II\n    Tsiroanomandidy\nAnosy\nUnknown\n    Tsiroanomandidy\nBelobaka\nUnknown, Fenoarivo\n    Tsiroanomandidy\nBevato\nUnknown, Bevato\n    Tsiroanomandidy\nMahasolo\nMahasolo, Unknown, Soafierenana\n    Tsiroanomandidy\nTsinjoarivo Imanga\nUnknown\n    Tsiroanomandidy\nTsiroanomandidy Fihaonana\nUnknown, Amparihinomby, Amparihibe\n    Tsiroanomandidy\nNA\nUnknown\n    Tsivory\nEbelo\nUnknown, Anarafito, Anaramaliniky, Bevalay, Ebelo Tsaramandroso, Valohazomanga\n    Tsivory\nMahaly\nAdabolava Sud, Unknown, Amboangy, Bepimay, Beza, Mahaly, Vohitelo, Mahazoarivo\n    Tsivory\nTranomaro\nUnknown, Amboropotsy, Antsira, Beteny, Tranomaro II, Tranomaro I, Tsilamaha I, Tsilamaha II\n    Tsivory\nTsivory\nUnknown, Imanjola, Marovotry, Ankily, Tsivory\n    Tsivory\nNA\nUnknown\n  \n  \n  \n\n\n\n\n\nWe compare this with the ROR documentation to assess which villages might have been omitted by our algorithm.\n\n\n3.5.3 Visual exploration and avenues for continuous corrections\nWe visually explore the the georeferenced data to observe its spatial distribution and spot eventual anomalies or clustering patterns that might not be immediately obvious from numerical summaries. The visualization below maps out our matched municipalities alongside villages. Discrepancies or clusters may indicate a need for further refinement or correction.\n\n\nCode\ncommmune_pcode_years &lt;- correspondence_table3 %&gt;%\n  # Split and unnest the years\n  mutate(years = str_split(years, \", \")) %&gt;%\n  unnest(years) %&gt;%\n  # Convert years to numeric for proper sorting\n  mutate(years = as.numeric(years)) %&gt;%\n  # Group by ADM3_PCODE and extract unique, sorted years\n  group_by(ADM3_PCODE) %&gt;%\n  summarize(years = list(unique(years))) %&gt;%\n  ungroup() %&gt;%\n  # Sort and collapse the years\n  mutate(years = map_chr(years, ~ paste(sort(.x), collapse = \", \")))\n\nfokontany_pcode_years &lt;- correspondence_table3 %&gt;%\n  # Split and unnest the years\n  mutate(years = str_split(years, \", \")) %&gt;%\n  unnest(years) %&gt;%\n  # Convert years to numeric for proper sorting\n  mutate(years = as.numeric(years)) %&gt;%\n  # Group by ADM3_PCODE and extract unique, sorted years\n  group_by(ADM4_PCODE) %&gt;%\n  summarize(years = list(unique(years))) %&gt;%\n  ungroup() %&gt;%\n  # Sort and collapse the years\n  mutate(years = map_chr(years, ~ paste(sort(.x), collapse = \", \")))\n\nselected_communes &lt;- commmune_pcode_years %&gt;%\n  filter(!is.na(ADM3_PCODE)) %&gt;%\n  left_join(obs_communes, by = \"ADM3_PCODE\") %&gt;%\n  st_sf()\n\nselected_fokontany &lt;- fokontany_pcode_years %&gt;%\n  filter(!is.na(ADM4_PCODE)) %&gt;%\n  left_join(fokontany, by = \"ADM4_PCODE\") %&gt;%\n  st_sf()  %&gt;%\n  mutate(label = \"Surveyed______\")\n\nwrite_rds(selected_communes, \"output/selected_communes.rds\")\nwrite_rds(selected_fokontany, \"output/selected_fokontany.rds\")\n\ntmap_mode(\"view\")\ntm_shape(selected_communes) + \n  tm_fill(col = \"OBS_NAME\", palette = \"Set1\", title = \"Observatory\",\n          id = \"ADM3_EN\",\n          popup.vars = c(\"Observatory\" = \"OBS_NAME\",\n                         \"Data collection years\"  = \"years\",\n                         \"District\" = \"ADM2_EN\",\n                         \"Region\" = \"ADM1_EN\")) +\n  tm_shape(selected_fokontany) + \n  tm_fill(col = \"label\", palette = c(\"black\"), alpha = 0.6, title = \"Fokontany\", \n          id = \"ADM4_EN\",\n          popup.vars = c(\"Observatory\" = \"OBS_NAME\",\n                         \"Data collection years\"  = \"years\",\n                         \"Commune\" = \"ADM3_EN\",\n                         \"District\" = \"ADM2_EN\",\n                         \"Region\" = \"ADM1_EN\")) +\n  tm_scale_bar()\n\n\n\n\n\n\nFigure 3.2: Map of the surveyed communes and fokonany"
  },
  {
    "objectID": "03-ror-data-georeferencing.html#conclusion",
    "href": "03-ror-data-georeferencing.html#conclusion",
    "title": "3  Georeferencing",
    "section": "3.6 Conclusion",
    "text": "3.6 Conclusion\nGiven the variability in location labels recorded in the ROR data, we emphasized standardizing and aligning toponyms. We introduced the clean_string function to unify place names, addressing variances in language, letter casing, and other descriptors. Utilizing fuzzy matching, we connected similar text strings, using the Levenshtein distance as a benchmark. To heighten accuracy, a hierarchical data matching strategy was applied, reflecting the inherent structure of geographical units, where regions envelop districts, which further consist of municipalities and localities. The COD data, curated by BNGRC and OCHA, was our reference point for these matches. Various techniques, including hierarchical fuzzy matching and visual checks, were employed.\nAs a result, 98% of commune name variations in the dataset matched with an official commune, and 73% of village name variations correlated with a fokontany. The outcomes are consistent with ROR’s internal documentation, and the spatial representations can be further inspected for validation. Future corrections and enhancements are anticipated, and our system, leveraging Quarto notebook and reproducible R code, is poised to facilitate these refinements.\nROR began its data collection at a time when geolocation best practices weren’t as evolved as they are today. Should more survey rounds be conducted in the future, the intricate georeferencing process demonstrated here should serve both as a cautionary tale and a guide on optimizing data registration (for instance, using PCODES). We’re optimistic that refining the georeferencing of past ROR data, as presented in this work, will amplify the data’s utility for both research and policy decisions."
  },
  {
    "objectID": "04-ror-data-preparation.html#data-anonymization",
    "href": "04-ror-data-preparation.html#data-anonymization",
    "title": "4  Data preparation",
    "section": "4.1 Data anonymization",
    "text": "4.1 Data anonymization\nTo be completed"
  },
  {
    "objectID": "04-ror-data-preparation.html#table-naming",
    "href": "04-ror-data-preparation.html#table-naming",
    "title": "4  Data preparation",
    "section": "4.2 Table naming",
    "text": "4.2 Table naming\nTo be completed"
  },
  {
    "objectID": "04-ror-data-preparation.html#data-format-conversions",
    "href": "04-ror-data-preparation.html#data-format-conversions",
    "title": "4  Data preparation",
    "section": "4.3 Data format conversions",
    "text": "4.3 Data format conversions\n\n\nCode\n# Install the latest version of DDIwR\nremotes::install_github(\"https://github.com/dusadrian/DDIwR\")\nlibrary(DDIwR)\n\n# Test on one package\n\ntest_file &lt;- (\"data/ROR_data/2010/res_m_a.dta\")\n\nconvert(from = test_file,\n        to = \"output/test.xml\")\nconvert(from = test_file,\n        to = \"output/test.rds\",\n        )\n\ntest &lt;- read_rds(\"output/test.rds\")\n\ntest2 &lt;- read_dta(test_file)\n\n\nTo be completed"
  },
  {
    "objectID": "05-bibliography.html",
    "href": "05-bibliography.html",
    "title": "References",
    "section": "",
    "text": "Gubert, Flore, and Anne-Sophie Robilliard. 2008. “Risk and\nSchooling Decisions in Rural Madagascar: A Panel Data-Analysis.”\nJournal of African Economies 17 (2): 207–38. https://doi.org/10.1093/jae/ejm010.\n\n\nVaillant, Julia. 2013. “Attrition and Follow-Up Rules in Panel\nSurveys: Insights from a Tracking Experience in Madagascar.”\nReview of Income and Wealth 59 (3): 509–38. https://doi.org/10.1111/j.1475-4991.2012.00505.x."
  },
  {
    "objectID": "03-ror-data-georeferencing.html#shared-geographing-reference-system",
    "href": "03-ror-data-georeferencing.html#shared-geographing-reference-system",
    "title": "3  Georeferencing",
    "section": "3.1 Shared geographing reference system",
    "text": "3.1 Shared geographing reference system\nIn this notebook, our primary objective is to enhance the georeferencing of the ROR survey data for open data sharing. The initial ROR survey, initiated in 1995, recorded geographical information in varying formats: from “village” to a combination of “municipality”, “village”, and “site”. A significant challenge arose from the fact that while data collection started in 1995, municipalities were only formally established in 1994, with several years required for stabilization. The inherent fluidity in toponyms, predominantly derived from oral traditions, resulted in varied written representations. Our endeavor is to identify, disambiguate, and georeference observations recorded in the ROR data, adopting the Common Operational Datasets (CODs) as a reference, which has been collaboratively defined by OCHA and Madagascar’s BNGRC (National Disaster Management Office).\n\n3.1.1 The Common Operational Dataset\nCODs stand as the bedrock for all preparedness and response operations, especially within the humanitarian sector. Adopted by the IASC in 2008 and revised in 2010, these datasets are pivotal for facilitating informed decision-making during the critical initial hours of a crisis. By ensuring consistency among stakeholders, they simplify data management and establish a shared operational picture of a crisis. Particularly relevant for our purpose is the incorporation of P-codes in CODs. These unique geographic identification codes, found in both Administrative Boundary CODs (COD-ABs) and Population Statistics CODs (COD-PSs), surmount challenges posed by variations in placenames and spellings. For instance, in Madagascar, 81 different administrative level 4 (ADM4) features are labeled “Morafeno”, with six of these existing within ADM3 features also termed “Morafeno”, distinguishable solely by their unique ADM2 features.\nP-codes act as reliable geographic identifiers, eliminating errors arising from identical or variably spelled geographic locations. Leveraging the HDX platform, an open platform for cross-crisis data sharing, we fetch this data to ensure the accurate georeferencing of our ROR data. By harnessing the standardized and official spelling of places provided by P-codes, we can amalgamate, harmonize, and analyze data from diverse sources, offering a comprehensive, geo-accurate view of the survey’s findings.\nAlthough there’s an element of harmonization achieved, especially regarding certain variables and household identifiers, the data varies in terms of geographical granularity. Initial years primarily provide a singular field denoting the village name. As the years progress, this evolves to include a municipality name, and in the latter years, an additional “site” name occasionally appears. A comprehensive overview of the observations can be gleaned from the “res_deb.dta” files within each year.\n\n\n3.1.2 Administrative boundaries\nThe “Madagascar Subnational Administrative Boundaries” dataset is sourced from the Common Operational Datasets (CODs), which offer authoritative reference datasets for decision-making during humanitarian operations. Specifically designed to streamline the discovery and exchange of pivotal data, CODs ensure uniformity and use the ‘best available’ datasets. This particular dataset focuses on administrative boundaries, including gazetteers with P-codes, facilitating organized humanitarian assessments and data management. P-codes act as unique identifiers for every administrative unit and populated area, ensuring standardization in nomenclature. When datasets adhere to the P-code standard, their integration and analysis become efficient. The dataset provides comprehensive boundary information for Madagascar at five administrative levels: country, region, district, commune, and fokontany. It’s accessible for download as shapefiles from the provided link.\n\n\n3.1.3 Localities\nThe “Madagascar Populated Places” dataset is also part of the Common Operational Datasets (CODs). This dataset encompasses populated place points for Madagascar. The data has been sourced from the National Geospatial-Intelligence Agency and provided by the University of Georgia - ITOS. Further, the Geographic Information Support Team (GIST) has taken up the role of distributor, with the data being published on 2007-03-07. UN OCHA ROSA has enhanced the dataset by adding P-codes and administrative boundary names, which are based on the BNGRC (National Disaster Management Office) data. The dataset geolocates 28184 populated places with their toponyms (names), codes related to various administrative levels such as fokontany, commune, district, and region, and their spatial coordinates.\n\n\nCode\n# Load datasets\nROR_surveys_2007 &lt;- read_dta(paste0(ror_data_loc, \"2007/res_deb.dta\"))\nobservatory_names &lt;- read_xlsx(\"references/observatory_names.xlsx\")\nobs_communes &lt;- st_read(\n  \"data/Spatial_data/Observatoires_ROR_communes_COD_v3.gpkg\",\n  quiet = TRUE) %&gt;%\n  left_join(select(observatory_names, name, code), \n            by = c(\"OBS_NAME\" = \"name\")) %&gt;%\n  rename(OBS_CODE = code)\npop_places &lt;- st_read(\n  \"data/Spatial_data/OCHA_BNGRC populated places/mdg_pplp_places_NGA_OCHA.shp\", quiet = TRUE)"
  },
  {
    "objectID": "03-ror-data-georeferencing.html#georeferencing-methodology",
    "href": "03-ror-data-georeferencing.html#georeferencing-methodology",
    "title": "3  Georeferencing",
    "section": "3.2 Georeferencing methodology",
    "text": "3.2 Georeferencing methodology\n\n3.2.1 Simplify strings\nThe treatment of toponyms presents a unique challenge, especially when these names are captured from varied sources. In the dataset, these names can vary due to differences in languages, case sensitivity, and the inclusion of additional descriptive terms. To address this, the clean_string function was developed. This function begins by converting all strings to lowercase, ensuring that subsequent comparisons are not sensitive to case variations. Next, to create a uniform standard, all non-alphanumeric characters are removed, retaining only spaces and the alphanumeric content. Common qualifiers in toponyms, such as “centre”, “haut” (high) or “bas” (low), which are not used consistently across records, are also removed. Given the bilingual nature of the dataset, with entries potentially in both Malagasy and French, the function translates cardinal points to the Malagasy language to ensure uniformity. Lastly, certain locales with multiple names, such as “Fort Dauphin”, also known as “Taolagnaro”, “Tolagnaro” or “Tolanaro”, are standardized to a single term, “Tolanaro”, to eliminate potential disparities. We also address instances of Roman numerals from I to VI, converting them to their Arabic numeral counterparts, ensuring consistent representation across records.\n\n\nCode\nclean_string &lt;- function(x){\n  x %&gt;%\n    tolower() %&gt;% # Convert to lowercase\n    # Retain spaces, remove other non-alphanumeric characters\n    str_replace_all(\"[^[:alnum:][:space:]]\", \" \") %&gt;% \n    str_remove_all(\"\\\\b(centre|haut|bas|androy)\\\\b\") %&gt;%\n    str_trim() %&gt;% # Trim spaces from start and end of string\n    str_replace_all(\"\\\\bcentre\\\\b\", \"\") %&gt;% # Remove the word 'centre'\n    # Translate cardinal points\n    str_replace_all(\"\\\\bnord\\\\b\", \"avaratra\") %&gt;% \n    str_replace_all(\"\\\\best\\\\b\", \"atsinanana\") %&gt;%\n    str_replace_all(\"\\\\bouest\\\\b\", \"andrefana\") %&gt;% \n    str_replace_all(\"\\\\bsud\\\\b\", \"atsimo\") %&gt;% \n    str_replace_all(\"\\\\batsinana\\\\b\", \"atsinanana\") %&gt;% # Replace short form \n    str_replace_all(\"(fort dauphin)|(taolagnaro)|(tolagnaro)\", \n                    \"tolanaro\") %&gt;% # Variations for fort dauphin\n    # Convert Roman numerals to Arabic\n    str_replace_all(\"\\\\bi\\\\b\", \"1\") %&gt;% \n    str_replace_all(\"\\\\bii\\\\b\", \"2\") %&gt;%\n    str_replace_all(\"\\\\biii\\\\b\", \"3\") %&gt;% \n    str_replace_all(\"\\\\biv\\\\b\", \"4\") %&gt;% \n    str_replace_all(\"\\\\bv\\\\b\", \"5\") %&gt;% \n    str_replace_all(\"\\\\bvi\\\\b\", \"6\")\n}\n\n\n\n\n3.2.2 Fuzzy matching\nBy default, statistical softwares and computing language match text by pairing only identical strings. Exact string matching is inappropriate in our context, where location data entry was subject to human errors like typographical mistakes or minor variations in spelling. To avoid this rigidity, fuzzy matching is employed. This approach gauges the degree of similarity between two strings, bypassing the need for an exact character-to-character match. The principle metric adopted for this is the “Levenshtein distance”, which quantifies the minimum number of single-character edits required to change one string into another. The fuzzy_match function encapsulates this approach. The function initiates the process by filtering the reference list of encontered toponyms based on a given observatory code, which considerably narrows down potential matches. Then, using the Jaro-Winkler distance metric — a variant of the Levenshtein distance particularly suited for shorter strings — the function computes the similarity between the target string and entries in the filtered reference. To ensure that only relevant matches are acknowledged, a threshold, termed max_distance, is set. Matches that exceed this threshold are disregarded. For those that pass this validation, the function then extracts the pertinent details of the matched row from the reference dataframe.\n\n\nCode\nfuzzy_match &lt;- function(target_string, dataframe, column_name, observatory_code, \n                        max_distance = 0.25) {\n  # Filter the dataframe based on observatory_code\n  filtered_reference &lt;- dataframe %&gt;%\n    filter(OBS_CODE == observatory_code) %&gt;%\n    select(all_of(column_name), ADM3_PCODE, ADM3_EN)\n  \n  # If filtered_reference is empty, return NA values\n  if (nrow(filtered_reference) == 0) {\n    return(list(matched_string = NA, ADM3_PCODE = NA, ADM3_EN = NA, distance = 1))\n  }\n  \n  # Use stringdist to find the closest match\n  distances &lt;- stringdist::stringdistmatrix(target_string, filtered_reference[[column_name]], method = \"jw\")\n  \n  # If there are no valid distances, set min_distance to Inf (this should help avoid the error)\n  if(all(is.na(distances))) {\n    min_distance &lt;- Inf\n  } else {\n    min_distance &lt;- min(distances, na.rm = TRUE)  # Ensure NA values don't affect the min calculation\n  }\n  \n  # Check for Inf distance and replace it with 1\n  if (is.infinite(min_distance)) {\n    min_distance &lt;- 1\n  }\n  \n  # If min_distance exceeds the max_distance threshold, return NA values\n  if (min_distance &gt; max_distance) {\n    return(list(matched_string = NA, ADM3_PCODE = NA, ADM3_EN = NA, distance = NA))\n  }\n  \n  matched_row &lt;- filtered_reference[which.min(distances), ]\n  \n  return(list(matched_string = matched_row[[column_name]], \n              ADM3_PCODE = matched_row$ADM3_PCODE, \n              ADM3_EN = matched_row$ADM3_EN, \n              distance = min_distance))\n}\n\n\n\n\n3.2.3 Hierarchical matching of data\nThe hierarchical organization of spatial entities is key for our challenge. Such an organization allows for a cascading representation of data, from broader scopes narrowing down to more specific layers. This representation is reminiscent of the defining order of geographical entities: regions contain provinces, which contain municipalities, and these in turn contain localities. In the georeferencing context, leveraging this hierarchical structure can lead to more precise matches. For instance, if an observatory code is associated with a specific district, the search for matches is confined to that district, enhancing both the efficiency and accuracy of the process. Figure 3.1 represents this hierarchical arrangement, serving as a roadmap for the subsequent data matching tasks.\n\n\n\n\ngraph TD\n\nA[Legend]\n\nW[ ]\nX[ ]\nY[ ]\nZ[ ]\n\nW --&gt;|Pre-definede hierarchy| X\nY -.-|Implemented matching|Z\n\n\n\n\n\n\n\n\n\n\ngraph TD\n\n%% Administrative Logic\nsubgraph \"Administrative Logic\"\nA[Region]\nB[District]\nC[Commune]\nD[Fokontany]\nI[Populated places]\n\nA --&gt; B\nB --&gt; C\nC --&gt; D\nD --&gt; I\nend\n\n%% Observatory Logic\n\nsubgraph \"Observatory Logic\"\nE[Observatory network]\nF[Observatory]\nG[Commune]\nH[Village]\nJ[Site]\n\nE --&gt; F\nF --&gt; G\nG --&gt; H\nF --&gt; H\nH--&gt; J\nend\n\n%% Geospatial matching\nH -.- I\nC -.- G\n\n\nFigure 3.1: Spatial entities pre-defined relationship and matching\n\n\n\n\nMadagascar’s current administrative setup is straightforward: regions contain districts; districts have communes; and communes are made up of Fokontany. Though a Fokontany should in principle be a single village, it often includes multiple villages or populated areas. It’s worth noting that while the idea of communes has been around for a while, they were only officially recognized in 1994. However, rolling them out took some time after 1994. Before 1994, “communes” simply described local government areas without any formal administrative status. The regions were created in 2004. On the ROR side, observatory refereed during the first surveys to villages. A systematic registry of the communes only started in the 2004 and 2005 round, depending on the observatories. A mention to “sites” also appeared in 2011 but was scarcely documented. Our strategy was to established links between the village information and populated places, and between communes."
  },
  {
    "objectID": "02-ror-data-attrition.html",
    "href": "02-ror-data-attrition.html",
    "title": "2  Panel attrition",
    "section": "",
    "text": "To assess the integrity of the panel data, we assess the attrition that characterizes it. That is, for each survey reiteration, we compute the percentage of household identified in the previous round that are still present in the subsequent round. Some adjustment must be made as households identification numbering system between 1995 and 1996. We also have to remove 2005 survey in Marovoay from the analysis, as this was a specific tracking survey intended to identify individuals from households that could not be re-interviewed in the previous years in one of the observatory sites (Vaillant 2013). This produces the following result:\n\n\nCode\nlibrary(tidyverse)    # A series of packages for data manipulation\nlibrary(haven)        # Required for reading STATA files (.dta)\nlibrary(labelled)     # To work with labelled data from STATA\nlibrary(readxl)       # Read data frames to Excel format\n\n# Obtain all years from the directory structure\nror_data_loc &lt;- \"data/ROR_data/\"\nyears &lt;- list.dirs(ror_data_loc, recursive = FALSE, full.names = FALSE)\n\n# Add observatory approximate location\nlocations &lt;- tibble(\n  code = c(1, 2, 3, 4, 12, 13, 15, 16, 21, 22, 23, 24, 31, 25, 41, 42, 43, 51, \n           44, 45, 61, 17, 18, 19, 71, 52),\n  name = c(\"Antalaha\", \"Antsirabe\", \"Marovoay\", \"Toliara coastal\", \"Antsohihy\", \n           \"Tsiroanomandidy\", \"Farafangana\", \"Ambovombe\", \n           \"Alaotra\", \"Manjakandriana\", \"Toliara North\", \n           \"Fenerive East\", \"Bekily\", \"Mahanoro\", \"Itasy\", \n           \"Menabe-Belo\", \"Fianarantsoa\", \"Tsivory\", \"Morondava\", \"Manandriana\", \n           \"Tanandava\", \"Ihosy\", \"Ambohimahasoa\", \"Manakara\", \"Tolanaro\", \n           \"Menabe North-East\"),\n  latitude = c(-14.8833, -19.8659, -16.1000, -23.7574, -14.8796, -18.7713, \n               -22.8167, -25.1667, -17.8319, -18.9167, -23.2941, -17.3500, \n               -24.6900, -19.9000, -19.1686, -19.6975, -21.4527, -24.4667, \n               -20.2833, -20.2333, -22.5711, -22.4000, -20.7145, -22.1333, \n               -25.0381, -20.5486),\n  longitude = c(50.2833, 47.0333, 46.6333, 43.6770, 47.9875, 46.0546, 47.8333, \n                46.0833, 48.4167, 47.8000, 43.7761, 49.4167, 45.1700, 48.8000,\n                46.7354, 44.5419, 47.0857, 45.4667, 44.2833, 47.3833, 45.0439, \n                46.1167, 47.0389, 48.0167, 46.9562, 47.1597))\n\n# Sort locations by latitude to generate sequence numbers\nlocations &lt;- locations %&gt;%\n  arrange(desc(latitude)) %&gt;%\n  mutate(seq_num = 1:n())\n\n\n# Function to read and process each file\nread_and_process &lt;- function(year) {\n  file_path &lt;- file.path(ror_data_loc, as.character(year), \"res_deb.dta\")\n  data &lt;- read_dta(file_path) %&gt;%\n    select(j0, j5) %&gt;%\n    mutate(year = year)\n  return(data)\n}\n\n# Use map to read and process files, then combine with bind_rows\nconsolidated_data &lt;- map_dfr(years, read_and_process) %&gt;%\n  mutate(year = as.numeric(year))\n\n# NB : j5 codes have been modified in 1996\n# so we need to replace the ones from 1995\nhh_96 &lt;- read_dta(paste0(ror_data_loc, \"1996/res_deb.dta\")) %&gt;%\n  select(j0, year, j5_96 = j5, j_1995, j12b) %&gt;%\n  filter(j_1995 == 1) %&gt;%\n  select(-j_1995) %&gt;%\n  mutate(year = 1995) %&gt;%\n  distinct(j12b, .keep_all = TRUE)\n\nconsolidated_data &lt;- consolidated_data %&gt;%\n  left_join(hh_96, by = c(\"j0\", \"year\", \"j5\" = \"j12b\")) %&gt;%\n  mutate(j5 = ifelse(year == 1995 & !is.na(j5_96), j5_96, j5)) %&gt;%\n  select(j0, j5, year)\n\n# We need also to discard the 2004 survey in Marovoay that is very particular\n# cf. Vaillant 2013.\nconsolidated_data &lt;- consolidated_data %&gt;%\n  filter(!(j0 == 3 & year == 2005))\n\n# Remove duplicates and create the hh_all table\nhh_all &lt;- consolidated_data %&gt;%\n  distinct(j0, j5, year, .keep_all = TRUE) %&gt;%\n  arrange(j0, j5)\n\nhh_grouped &lt;- hh_all %&gt;%\n  group_by(j0, year) %&gt;%\n  summarise(j5_list = list(j5), .groups = 'drop') %&gt;%\n  # Count the number of j5 in j5_list\n  mutate(j5_count = map_int(j5_list, length)) %&gt;%\n  # Create a column to identify the most recent previous year with data for the same observatory\n  group_by(j0) %&gt;%\n  mutate(previous_year = lag(year)) %&gt;%\n  ungroup()\n  \n# Self-join to create previous_year_j5_list\nattrition_rates_detail &lt;- hh_grouped %&gt;%\n  left_join(hh_grouped %&gt;% select(j0, year, \n                                  previous_year_j5_list = j5_list,\n                                  j5_count_previous_year = j5_count), \n            by = c(\"j0\", \"previous_year\" = \"year\")) %&gt;%\n  mutate(repeated_j5 = map_int(\n    seq_along(j5_list), \n    ~length(intersect(j5_list[[.]], previous_year_j5_list[[.]]))),\n    attrition_rate = (j5_count_previous_year - repeated_j5) /\n      j5_count_previous_year * 100)\n\n\n# Pivot the data to have years as columns and observatory numbers as rows\nattrition_rates &lt;- attrition_rates_detail  %&gt;%\n  select(j0, year, attrition_rate) %&gt;%\n  left_join(locations %&gt;%\n              mutate(observatory_with_num = paste0(seq_num, \". \", name),\n                     observatory_with_num = fct_reorder(observatory_with_num, \n                                                        latitude)) %&gt;%\n              select(code, name, observatory_with_num), \n            by = c(\"j0\" = \"code\")) %&gt;%\n  drop_na(name)\n\naverage_wo_outliers &lt;- attrition_rates %&gt;%\n  filter(attrition_rate &lt; 75) %&gt;%\n  summarise(mean = mean(attrition_rate))\n\naverage_wo_outliers &lt;- round(average_wo_outliers$mean, 1)\ncompound_avg_10y &lt;- round((1-(1-(average_wo_outliers/100))^10)*100) \n\nggplot(attrition_rates, \n       aes(x = year, y = observatory_with_num, \n           fill = attrition_rate)) +\n  geom_tile() +  # Create the heatmap tiles\n  geom_text(aes(label = ifelse(is.na(attrition_rate), \"\", \n                               round(attrition_rate))), \n            color = \"black\", size = 2.5) +\n  scale_fill_gradient2(low = \"darkgreen\", mid = \"yellow\", high = \"red\", \n                       midpoint = 30, na.value = \"grey\", name = \"Attrition Rate (%)\") +\nlabs(x = \"Year\",\n       y = \"Observatory (j0)\") +\n  theme_minimal() +\n  labs(y = NULL, x = NULL) +\n  theme(axis.text.y = element_text(size = 8)) \n\n\n\n\n\nFigure 2.1: Attrition rate of ROR panels per observatory and survey round\n\n\n\n\nAnnual attrition rates superior to 75% for a specific observatory are likely to be induced by new reshuffles of the household identification codes and we hope to be able to solve such issue later on. If we discard these outliers (attrition rates over 75%), we have an average attrition year of % wich is very high, leading to a compound attrition rate of % over 10 years. Attrition on ROR data has been studied Gubert and Robilliard (2008); Vaillant (2013).\n\n\n\n\nGubert, Flore, and Anne-Sophie Robilliard. 2008. “Risk and Schooling Decisions in Rural Madagascar: A Panel Data-Analysis.” Journal of African Economies 17 (2): 207–38. https://doi.org/10.1093/jae/ejm010.\n\n\nVaillant, Julia. 2013. “Attrition and Follow-Up Rules in Panel Surveys: Insights from a Tracking Experience in Madagascar.” Review of Income and Wealth 59 (3): 509–38. https://doi.org/10.1111/j.1475-4991.2012.00505.x."
  }
]